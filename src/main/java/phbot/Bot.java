/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package phbot;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.http.HttpRequestInitializer;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.json.jackson2.JacksonFactory;
import com.google.api.services.classroom.Classroom;
import com.google.api.services.classroom.model.Course;
import com.google.api.services.classroom.model.CourseWork;
import com.google.api.services.classroom.model.ListCourseWorkResponse;
import com.google.api.services.classroom.model.ListCoursesResponse;
import com.google.auth.http.HttpCredentialsAdapter;
import com.google.auth.oauth2.UserCredentials;

import discord4j.common.util.Snowflake;
import discord4j.core.DiscordClientBuilder;
import discord4j.core.GatewayDiscordClient;
import discord4j.core.event.domain.lifecycle.ReadyEvent;
import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.core.object.entity.Message;
import discord4j.core.object.entity.User;
import discord4j.core.object.entity.channel.TextChannel;

interface Command {
    void execute(MessageCreateEvent event);
}

public class Bot {
    private static final String APPLICATION_NAME = "phbot";
    private static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();
    static NetHttpTransport HTTP_TRANSPORT;
    private static Map<String, Command> commands = new HashMap<>();
    private static Map<Snowflake, String> channelCourseMapper;
    static Classroom service;

    private static HttpRequestInitializer getGoogleCredentials(final NetHttpTransport HTTP_TRANSPORT)
            throws IOException {
        UserCredentials credentials = UserCredentials.fromStream(new FileInputStream("oauth_tokens.json"));
        credentials.refreshIfExpired();
        return new HttpCredentialsAdapter(credentials);
    }

    static String readDiscordSecret() {
        BufferedReader fin;
        try {
            fin = new BufferedReader(new FileReader("discord_secret.txt"));
            try {
                String s = fin.readLine();
                fin.close();
                return s;
            } catch (IOException e) {
                System.out.println("Error: IOException while reading Discord secret");
            }
        } catch (FileNotFoundException e) {
            System.out.println("Error: Discord secret file missing");
        }
        return "";
    }

    static List<String> getCoursework(String courseId) throws Exception {
        Course course = service.courses().get(courseId).execute();
        List<String> returnList = new ArrayList<>();
        System.out.println("Course requested:");
        System.out.printf("%s\n", course.getName());
        ListCourseWorkResponse courseWorkResponse = service.courses().courseWork().list(courseId).setPageSize(3)
                .execute();
        List<CourseWork> courseWork = courseWorkResponse.getCourseWork().stream().filter(w -> {
            var googleDate = w.getDueDate();
            if (googleDate == null)
                return true;
            Calendar dueDate = Calendar.getInstance();
            dueDate.set(googleDate.getYear(), googleDate.getMonth() - 1, googleDate.getDay());
            return dueDate.compareTo(Calendar.getInstance()) > 0;
        }).collect(Collectors.toList());
        if (courseWork == null || courseWork.size() == 0) {
            System.out.println("\tNo upcoming coursework.");
            returnList.add("No upcoming coursework.");
        } else {
            returnList.add("Upcoming coursework for **" + course.getName() + "**:");
            returnList.addAll(courseWork.stream().map(i -> {
                System.out.println(i.getTitle());
                return "> " + i.getTitle();
            }).collect(Collectors.toList()));
        }
        return returnList;
    }

    public static void main(String[] args) throws Exception {
        channelCourseMapper = ((Map<String, String>) JSON_FACTORY
                .fromInputStream(new FileInputStream("snowflake_to_course.json"), Map.class)).entrySet().stream()
                        .collect(Collectors.toMap(e -> Snowflake.of(e.getKey()), Map.Entry::getValue));

        // Build a new authorized API client service.
        HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
        service = new Classroom.Builder(HTTP_TRANSPORT, JSON_FACTORY, getGoogleCredentials(HTTP_TRANSPORT))
                .setApplicationName(APPLICATION_NAME).build();

        commands.put("ping", event -> {
            System.out.println("Pong!");
            event.getMessage().getChannel().flatMap(channel -> channel.createMessage("Pong!")).subscribe();
        });

        commands.put("cw", event -> event.getMessage().getChannel().flatMap(channel -> {
            Snowflake chId = channel.getId();
            System.out.println(((TextChannel) channel).getName() + ": " + chId.asString());
            String courseId = channelCourseMapper.get(chId);
            if (courseId.equals("")) {
                return channel.createMessage("This is not a class channel.");
            }
            List<String> courseWork;
            try {
                courseWork = getCoursework(courseId);
            } catch (Exception e) {
                courseWork = new ArrayList<>();
                courseWork.add("No upcoming coursework.");
            }
            String message = "";
            for (String s : courseWork) {
                message += s + "\n";
            }
            return channel.createMessage(message);
        }).subscribe());

        GatewayDiscordClient client = DiscordClientBuilder.create(readDiscordSecret()).build().login().block();

        client.getEventDispatcher().on(ReadyEvent.class).subscribe(event -> {
            User self = event.getSelf();
            System.out.println(String.format("Logged in as %s#%s", self.getUsername(), self.getDiscriminator()));
        });

        client.getEventDispatcher().on(MessageCreateEvent.class).subscribe(event -> {
            System.out.println("MessageCreateEvent fired");
            final String content = event.getMessage().getContent();
            for (final Map.Entry<String, Command> entry : commands.entrySet()) {
                if (content.startsWith('!' + entry.getKey())) {
                    System.out.println(entry.getKey() + " command");
                    entry.getValue().execute(event);
                    break;
                }
            }
        });

        client.onDisconnect().block();
    }
}